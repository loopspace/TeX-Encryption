%D \module
%D   [     file=t-enigma,
%D      version=2012-02-21 10:59:43+0100,
%D        title=\CONTEXT\ User Module,
%D     subtitle=Enigma,
%D       author=Philipp Gesang,
%D         date=\currentdate,
%D    copyright=Philipp Gesang,
%D      license=2-clause BSD,
%D        email={gesang at stud dot uni-heidelberg dot de}]
%C This module is licensed under the conditions of the BSD license with
%C two clauses. There is a copy in a file named "COPYING" in the
%C t-enigma source tree.

\unprotect

\writestatus{loading} {ConTeXt module / Enigma Document Encryption}

\startinterface all
  \setinterfacevariable {enigma} {enigma}
\stopinterface

\definenamespace [\v!enigma] [
 \v!command=\v!no,
    comment=Enigma Document Encryption,
    \s!name=\v!enigma,
  \s!parent=\v!enigma,
      % setup=\v!list,
      setup=\v!no,
      style=\v!no,
       type=module,
    version=hg-tip,
]

%D Loading the \LUA\ conversion routines.

\startluacode
thirddata = thirddata or { }
\stopluacode
\registerctxluafile{enigma}

%D \startdocsection[title=Macro Generator]
%D \startparagraph
%D The main setup. The \texmacro{defineenigma} macro does not adhere to
%D the reommended practis of automatical macro derivation. Rather, we
%D have our own parser do the job of setting globals. This is a
%D consequence of the intention to offer the same behavior in any of the
%D three main formats, \PLAIN, \CONTEXT and \LATEX. Hence, we don’t rely
%D on the internal mechanisms but implement our own macro generator.
%D \stopparagraph

\def\do_do_define_enigma#id{%
  \edef\enigmaid{#id}%
  \expandafter\gdef\csname start\enigmaid\endcsname{%
    \endgraf
    \bgroup
    \ctxlua{
      if thirddata.enigma.machines["#id"] then
        nodes.tasks.enableaction("processors",
                                 "thirddata.enigma.callbacks.#id")
      else
        print([[ENIGMA: No machine of that name: #id!]])
      end
    }%
  }%
  %
  \expandafter\gdef\csname stop\enigmaid\endcsname{%
    \endgraf%% We need to force a paragraph here for the callback to be
            %% applied.
    \ctxlua{
      nodes.tasks.disableaction("processors",
                                "thirddata.enigma.callbacks.#id")
      thirddata.enigma.machines["#id"]:processed_chars()
    }%
    \egroup%
  }%
}

\def\inherit_enigma#to#from{%
  \ctxlua{%
    local enigma       = thirddata.enigma
    local current_args = enigma.retrieve_raw_args(\!!bs#from\!!es)
    enigma.new_callback(enigma.new_machine(current_args, \!!bs#to\!!es),
                        \!!bs#to\!!es)
  }%
  \do_do_define_enigma{#to}%
}

\def\do_define_enigma[#id][#secondid]{%
  \ifsecondargument %% Copy an existing machine and callback.
    \inherit_enigma{#id}{#secondid}%
  \else             %% Create a new machine.
    \iffirstargument
      \do_do_define_enigma{#id}%
    \else
      \donothing
    \fi
  \fi
  \endgroup%
}

\def\defineenigma{%
  \begingroup
  \dodoubleempty\do_define_enigma%
}

%D \stopdocsection

%D \startdocsection[title=Setup]
\def\do_do_setup_enigma#args{%
    \ctxlua{
      local enigma = thirddata.enigma
      local current_args =
        enigma.parse_args(\!!bs\detokenize{#args}\!!es)
      enigma.save_raw_args(current_args, \!!bs\currentenigmaid\!!es)
      enigma.new_callback(
        enigma.new_machine(current_args,
                           \!!bs\currentenigmaid\!!es),
        \!!bs\currentenigmaid\!!es)
    }%
}

%D \startparagraph
%D The module setup \texmacro{setupenigma} expects key=value, notation.
%D All the logic is at the Lua end, not much to see here …
%D \stopparagraph

\def\do_setup_enigma[#id][#args]{%
  \ifsecondargument
    \edef\currentenigmaid{#id}
    \pushcatcodetable
    \catcodetable \txtcatcodes
      \do_do_setup_enigma{#args}%
  \else
    \donothing
  \fi
  \popcatcodetable
  \egroup%
}

\def\setupenigma{%
  \bgroup
  \dodoubleempty\do_setup_enigma%
}

%D \stopdocsection

\protect
% vim:ft=context:sw=2:ts=2:tw=72
